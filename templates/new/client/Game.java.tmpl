/*
This code was generated by codegame-cli-java.

CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
THE CODE IS REGENERATED.
*/
package {{.Package}}.{{.GameNameOneWord}};

import java.io.IOException;
import java.util.List;

import org.codegame.client.GameSocket;
import org.codegame.client.Session;
import org.codegame.client.GameSocket.EventCallback;

import com.beust.jcommander.JCommander;
import com.beust.jcommander.Parameter;
import com.beust.jcommander.Parameters;

import {{.Package}}.{{.GameNameOneWord}}.definitions.*;

/**
 * Game represents a {{.DisplayName}} game.
 */
public class Game {
    /**
     * The ID of the game.
     */
    public final String id;
    /**
     * The config of the game.
     */
    public final GameConfig config;
    /**
     * Whether the socket is connected as a spectator.
     */
    public final boolean spectating;

    private String joinSecret;
    private final GameSocket socket;

    @Parameters(commandDescription = "Create and join new game.", commandNames = "create")
    private static class CLICreate {
        @Parameter(names = "--public", description = "Make the created game public.")
        public boolean publicFlag;
        @Parameter(names = "--protected", description = "Make the created game protected.")
        public boolean protectedFlag;
        @Parameter(names = "--spectate", description = "Spectate the created game. The username is not necessary if this flag is set.")
        public boolean spectateFlag;
        @Parameter(description = "<username>")
        public List<String> positionalParams;
    }

    @Parameters(commandDescription = "Join an existing game.", commandNames = "join")
    private static class CLIJoin {
        @Parameter(names = "--spectate", description = "Spectate the game. The username is not necessary if this flag is set.")
        public boolean spectateFlag;
        @Parameter(description = "<game_id> <username> <join_secret?>")
        public List<String> positionalParams;
    }

    @Parameters(commandDescription = "Reconnect with an existing session.", commandNames = "reconnect")
    private static class CLIReconnect {
        @Parameter(description = "<username>")
        public List<String> positionalParams;
    }

    /**
     * Parses the command line arguments and creates a new game depending on which
     * flags and commands are used.
     * <p>
     * Commands:
     * <p>
     * - create Creates a new game and joins it.
     * <p>
     * - join Joins an existing game.
     * <p>
     * - reconnect Reconnects to an existing session.
     * <p>
     * Flags:
     * <p>
     * - --public Makes the created game public.
     * <p>
     * - --protected Makes the created game protected.
     * <p>
     * - --spectate Spectates the game instead of joining it. (the username is not
     * necessary if this flag is set)
     * <p>
     *
     * @param args   The command line arguments of the application.
     * @param config The config to use when a new game is created.
     * @return A new Game instance.
     * @throws IOException Thrown when the operation fails.
     */
    public static Game fromArgs(String[] args, GameConfig config) throws IOException {
        if (config == null)
            config = new GameConfig();

        var cmdCreate = new CLICreate();
        var cmdJoin = new CLIJoin();
        var cmdReconnect = new CLIReconnect();
        var jc = JCommander.newBuilder().programName("test").addCommand(cmdCreate).addCommand(cmdJoin)
                .addCommand(cmdReconnect).build();
        jc.parse(args);

        Game game = null;

        if (jc.getParsedCommand() == null) {
            jc.usage();
            System.exit(1);
        }
        if (jc.getParsedCommand().equals("create")) {
            if ((cmdCreate.positionalParams == null || cmdCreate.positionalParams.size() == 0)
                    && !cmdCreate.spectateFlag) {
                System.err.println("'username' is required.");
                jc.usage();
                System.exit(1);
            }
            if (cmdCreate.spectateFlag) {
                game = createAndSpectateGame(cmdCreate.publicFlag, cmdCreate.protectedFlag, config);
            } else {
                game = createAndJoinGame(cmdCreate.positionalParams.get(0), cmdCreate.publicFlag,
                        cmdCreate.protectedFlag, config);
            }
            System.out.println("Game ID: " + game.id);
            if (cmdCreate.protectedFlag)
                System.out.println("Join secret: " + game.getJoinSecret());
        } else if (jc.getParsedCommand().equals("join")) {
            if (cmdJoin.positionalParams == null || cmdJoin.positionalParams.size() == 0) {
                System.err.println("'game_id' is required.");
                jc.usage();
                System.exit(1);
            }
            if (cmdJoin.positionalParams.size() == 1 && !cmdJoin.spectateFlag) {
                System.err.println("'username' is required.");
                jc.usage();
                System.exit(1);
            }
            var joinSecret = cmdJoin.positionalParams.size() == 3 ? cmdJoin.positionalParams.get(2) : "";
            if (cmdJoin.spectateFlag) {
                game = spectateGame(cmdJoin.positionalParams.get(0));
            } else {
                game = joinGame(cmdJoin.positionalParams.get(0), cmdJoin.positionalParams.get(1), joinSecret);
            }
        } else if (jc.getParsedCommand().equals("reconnect")) {
            if (cmdReconnect.positionalParams == null || cmdReconnect.positionalParams.size() == 0) {
                System.err.println("'username' is required.");
                jc.usage();
                System.exit(1);
            }
            game = reconnectGame(cmdReconnect.positionalParams.get(0));
        } else {
            jc.usage();
            System.exit(1);
        }

        return game;
    }

    /**
     * Creates a new game and joins it.
     *
     * @param username   The desired username.
     * @param makePublic Make the created game public.
     * @param protect    Protect the created game with a join secret.
     * @param config     The game config.
     * @return A new Game instance.
     * @throws IOException Thrown when the operation fails.
     */
    public static Game createAndJoinGame(String username, boolean makePublic, boolean protect, GameConfig config)
            throws IOException {
        var socket = new GameSocket(getURL());
        var data = socket.createGame(makePublic, protect, config);
        return joinGame(socket, data.id, username, data.joinSecret);
    }

    /**
     * Creates a new game and joins it as a spectator.
     *
     * @param makePublic Make the created game public.
     * @param protect    Protect the created game with a join secret.
     * @param config     The game config.
     * @return A new Game instance.
     * @throws IOException Thrown when the operation fails.
     */
    public static Game createAndSpectateGame(boolean makePublic, boolean protect, GameConfig config)
            throws IOException {
        var socket = new GameSocket(getURL());
        var data = socket.createGame(makePublic, protect, config);
        var game = spectateGame(socket, data.id);
        game.joinSecret = data.joinSecret;
        return game;
    }

    /**
     * Joins an existing game.
     *
     * @param gameId   The ID of the game.
     * @param username The desired username.
     * @return A new Game instance.
     * @throws IOException Thrown when the operation fails.
     */
    public static Game joinGame(String gameId, String username) throws IOException {
        return joinGame(gameId, username, "");
    }

    /**
     * Joins an existing game.
     *
     * @param gameId     The ID of the game.
     * @param username   The desired username.
     * @param joinSecret The join secret.
     * @return A new Game instance.
     * @throws IOException Thrown when the operation fails.
     */
    public static Game joinGame(String gameId, String username, String joinSecret) throws IOException {
        var socket = new GameSocket(getURL());
        return joinGame(socket, gameId, username, joinSecret);
    }

    /**
     * Spectates an existing game.
     *
     * @param gameId The ID of the game.
     * @return A new Game instance.
     * @throws IOException Thrown when the operation fails.
     */
    public static Game spectateGame(String gameId) throws IOException {
        var socket = new GameSocket(getURL());
        return spectateGame(socket, gameId);
    }

    /**
     * Reconnects to a previous session.
     *
     * @param username The username of the player.
     * @return A new Game instance.
     * @throws IOException Thrown when the operation fails.
     */
    public static Game reconnectGame(String username) throws IOException {
        var socket = new GameSocket(getURL());
        socket.restoreSession(username);
        var config = socket.getApi().fetchGameConfig(socket.getSession().getGameId(), GameConfig.class);
        return new Game(socket, socket.getSession().getGameId(), config, false, "");
    }

    private static Game joinGame(GameSocket socket, String gameId, String username, String joinSecret)
            throws IOException {
        socket.join(gameId, username, joinSecret);
        var config = socket.getApi().fetchGameConfig(gameId, GameConfig.class);
        return new Game(socket, gameId, config, false, joinSecret);
    }

    private static Game spectateGame(GameSocket socket, String gameId)
            throws IOException {
        socket.spectate(gameId);
        var config = socket.getApi().fetchGameConfig(gameId, GameConfig.class);
        return new Game(socket, gameId, config, true, "");
    }

    /**
     * Returns the value of the CG_GAME_URL environment variable or - if empty - a
     * hardcoded URL
     * for production builds.
     *
     * @return The game URL.
     */
    public static String getURL() {
        var url = System.getenv("CG_GAME_URL");
        if (url == null || url.isEmpty())
            throw new RuntimeException("The CG_GAME_URL environment variable must be set.");
        return url;
    }

	{{range .Commands}}
    /**
     * Sends a `{{.Name}}` command.
     *
     * @param data The command data.
     */
    public void send{{.PascalName}}({{.PascalName}}Cmd data) {
        socket.send("{{.Name}}", data);
    }
	{{end}}

	{{range .Events}}
    /**
     * Triggers the callback every time the `{{.Name}}` event is received.
     *
     * @param callback The callback to call.
     * @return The ID of the callback, which can be used to remove it again.
     */
    public String on{{.PascalName}}(EventCallback<{{.PascalName}}Event> callback) {
        return socket.on("{{.Name}}", {{.PascalName}}Event.class, callback);
    }

    /**
     * Triggers the callback the next time the `{{.Name}}` event is received.
     *
     * @param callback The callback to call.
     * @return The ID of the callback, which can be used to remove it again.
     */
    public String on{{.PascalName}}Once(EventCallback<{{.PascalName}}Event> callback) {
        return socket.once("{{.Name}}", {{.PascalName}}Event.class, callback);
    }
	{{end}}

    /**
     * Removes an event callback.
     *
     * @param eventName The name of the event.
     * @param id        The ID of the callback.
     */
    public void removeCallback(String eventName, String id) {
        socket.removeCallback(eventName, id);
    }

    /**
     * Retrieves the username of the player from the local player cache or fetches
     * it from the server if it is not yet in the cache.
     *
     * @param playerId The ID of the player.
     * @return The username of the player.
     * @throws IOException Thrown when the operation fails.
     */
    public String username(String playerId) throws IOException {
        return socket.username(playerId);
    }

    /**
     * @return The current session.
     */
    public Session getSession() {
        return socket.getSession();
    }

    /**
     * Returns the join secret of the current game. If the game was not created by
     * this socket, the join secret will be empty.
     *
     * @return The join secret.
     */
    public String getJoinSecret() {
        return joinSecret;
    }

    /**
     * Blocks until the connection is closed.
     */
    public void listen() {
        socket.listen();
    }

    /**
     * Closes the underlying websocket connection.
     */
    public void Close() {
        socket.close();
    }

    private Game(GameSocket socket, String id, GameConfig config, boolean spectating, String joinSecret) {
        this.id = id;
        this.config = config;
        this.spectating = spectating;
        this.joinSecret = joinSecret;
        this.socket = socket;
    }
}

